(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{367:function(t,a,e){"use strict";e.r(a);var c=e(42),r=Object(c.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react-17-rc版本特性介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-17-rc版本特性介绍"}},[t._v("#")]),t._v(" react 17 RC版本特性介绍")]),t._v(" "),e("p",[t._v("文档地址：https://github.com/reactjs/reactjs.org/blob/c30ff1e39b9fca747198c028a33300656a90e612/content/blog/2020-08-10-react-v17-rc.md")]),t._v(" "),e("h2",{attrs:{id:"新增特性-无功能特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#新增特性-无功能特性"}},[t._v("#")]),t._v(" 新增特性——无功能特性")]),t._v(" "),e("p",[t._v("React 17不太寻常，因为它没有添加任何面向开发人员的新功能，而主要侧重于升级简化React本身。\n我们正在积极开发React的新功能，但它们并不属于此版本。React 17是我们进行深度推广战略的关键所在。\n此版本之所以特殊，你可以认为React 17是一个过渡版，它会使得由一个React版本管理树嵌入到另一个React版本管理树中时会更加安全。")]),t._v(" "),e("h2",{attrs:{id:"逐步升级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#逐步升级"}},[t._v("#")]),t._v(" 逐步升级")]),t._v(" "),e("p",[t._v("React 17开始支持逐步升级React版本。当从React 15升到16时(或者从 React 16升到17时)，通常会一次升级整个应用程序。这适用于大部分应用程序。但是，如果代码库是在几年前编写的，并且并没有得到很好的维护，那么升级它会变得越来越有挑战性。尽管可以在页面上使用两个版本的React，但是直到React 17依然会出现events问题。\n为了实现逐步升级，我们需要对React的事件系统进行一些更改。而这些更改可能会对代码产生影响，这也是React 17成为主要版本的原因。实际上，十万个以上的组件中受影响的组件不超过20个，因此我们希望大多数应用程序都可以升级到React 17，而不会产生太多影响。")]),t._v(" "),e("h2",{attrs:{id:"更改事件委托"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更改事件委托"}},[t._v("#")]),t._v(" 更改事件委托")]),t._v(" "),e("p",[t._v("对大多数事件来说，React并不会将它们附加到DOM节点上。相反，React会直接在document节点上为每种事件类型附加一个处理器，这被称为事件委托。除了在大型应用程序上具有性能优势外，它还使添加类似于replaying events这样的新特性变得更容易。")]),t._v(" "),e("p",[t._v('自从其发布以来，React就一直自动进行事件委托。当document上触发DOM事件时，React会找出调用的组件，然后 React事件会在组件中向上"冒泡"。但实际上，原生事件已经冒泡出了"document"级别，React是在document中安装的事件处理器。')]),t._v(" "),e("p",[t._v("但这就是逐步升级的困难所在。")]),t._v(" "),e("p",[t._v("如果页面上有多个React版本，他们都将在顶层注册事件处理器。这会破坏e.stopPropagation() 如果嵌套树结构中阻止了事件冒泡，但外部树依然能接收到它。这会使不同版本React的嵌套变得十分困难。\n在React 17中，React将不再向document添加事件处理器。而会将事件处理器附加到渲染React树的根DOM节点中：\n在React 16或更早版本中，React会对大多数事件执行document.addEventListener()。React 17将会在底层调用rootNode.addEventListener()。\n"),e("img",{attrs:{src:"2020-08-17-18-10-54.png",alt:"react事件绑定变化"}})]),t._v(" "),e("h2",{attrs:{id:"去除事件池"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#去除事件池"}},[t._v("#")]),t._v(" 去除事件池")]),t._v(" "),e("p",[t._v("因为React在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为null。在 React 16及更早版本中，使用者必须调用e.persist()才能正确的使用该事件，或者正确读取需要的属性。")]),t._v(" "),e("p",[t._v("在 React 17 中，此代码可以按照预期效果执行。旧的事件池优化操作已被完成删除，因此，使用者可以在需要时读取事件字段。")]),t._v(" "),e("p",[t._v("这改变了行为，因此我们将其标记为重大更新，但在实践中我们没有看到它在Facebook上造成影响(甚至还修复了一些bug！)。请注意，e.persist()在 React事件对象中仍然可用，只不过没有任何效果罢了。")]),t._v(" "),e("h2",{attrs:{id:"副作用清理时机"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#副作用清理时机"}},[t._v("#")]),t._v(" 副作用清理时机")]),t._v(" "),e("p",[t._v("大多数副作用(effect)不需要延迟刷新视图，因此React在屏幕上反映出更新后立即异步执行它们(在极少数情况下，你需要一种副作用来阻止重绘。例如，如果需要获取尺寸和位置，请使用useLayoutEffect)。")]),t._v(" "),e("p",[t._v("然而，副作用清理函数(如果存在)在React16中同步运行。我们发现，对于大型应用程序来说，这不是理想选择，因为同步会减缓视图的更新(例如，切换标签)。")]),t._v(" "),e("p",[t._v("在React 17中，副作用清理函数会异步执行 —— 如果要卸载组件，则清理会在视图更新后运行。")]),t._v(" "),e("p",[t._v("这反映了副作用本身如何更紧密地运行。在极少数情况下，你可能希望依靠同步执行，可以改用useLayoutEffect来代替。")]),t._v(" "),e("h2",{attrs:{id:"解决隐患"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决隐患"}},[t._v("#")]),t._v(" 解决隐患")]),t._v(" "),e("p",[t._v("例如，如果模块中使用document.addEventListener(...)手动添加了DOM监听，你可能希望能捕获到所有React 事件。在React 16或更早版本中，即使你在React事件处理器中调用e.stopPropagation()，你创建的DOM监听仍会触发，这是因为原生事件已经处于document级别。使用React 17冒泡将被阻止(按需)，因此你的document级别的事件监听不会触发\n返回一致的undefined错误以前，React只对class和函数组件执行此操作，但并不会检查forwardRef和memo组件的返回值。这是由于编码错误导致。在React 17中，forwardRef和memo组件的行为会与常规函数组件和class组件保持一致。在返回undefined时会报错")]),t._v(" "),e("p",[t._v("你可以将监听转换为使用事件捕获来修复此类代码。为此，你可以将{ capture: true }作为 document.addEventListener的第三个参数传递")]),t._v(" "),e("h2",{attrs:{id:"原生组件栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原生组件栈"}},[t._v("#")]),t._v(" 原生组件栈")]),t._v(" "),e("p",[t._v("当你在浏览器中遇到错误时，浏览器会为你提供带有JavaScript函数的名称及位置的堆栈信息。然而JavaScript堆栈通常不足以诊断问题，因为React树的层次结构可能同样重要。你不仅要知道哪个Button抛出了错误，而且还想知道 Button在React树中的哪个位置。")]),t._v(" "),e("p",[t._v('为了解决这个问题，当你遇到错误时，从React 16开始会打印"组件栈"信息。尽管如此，它们仍然不如原生的JavaScript堆栈。特别是它们在控制台中不可点击，因为React不知道函数在源代码中的声明位置。此外，它们在生产中几乎无用。不同于常规压缩后的JavaScript堆栈，它们可以通过sourcemap的形式自动恢复到原始函数的位置，而使用React组件栈，在生产环境下必须在堆栈信息和bundle大小间进行选择。')]),t._v(" "),e("p",[t._v("在React 17中，使用了不同的机制生成组件堆栈，该机制会将它们与常规的原生JavaScript堆栈缝合在一起。这使得你可以在生产环境中获得完全符号化的React组件堆栈信息。")]),t._v(" "),e("p",[t._v("React实现这一点的方式有点非常规。目前，浏览器无法提供获取函数堆栈框架(源文件和位置)的方法。因此，当 React捕获到错误时，将通过组件上述组件内部抛出的临时错误(并捕获)来重建其组件堆栈信息。这会增加崩溃时的性能损失，但每个组件类型只会发生一次。")]),t._v(" "),e("p",[t._v("如果你对此感兴趣，可以在这个PR中阅读更多详细信息，但是在大多数情况下，这种机制不会影响你的代码。从使用者的角度来看，新功能就是可以单击组件堆栈(因为它们依赖于本机浏览器堆栈框架)，并且可以像常规JavaScript错误那样在生产中进行解码。")]),t._v(" "),e("p",[t._v("构成重大变化的部分是，要使此功能正常工作，React将在捕获错误后在堆栈中重新执行上面某些函数和某些class构造函数的部分。由于渲染函数和class构造函数不应具有副作用(这对于SSR也很重要)，因此这不会造成任何实际问题。")]),t._v(" "),e("h2",{attrs:{id:"移除私有导出"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#移除私有导出"}},[t._v("#")]),t._v(" 移除私有导出")]),t._v(" "),e("p",[t._v("最后，值得注意的重大变化是我们删除了一些以前暴露给其他项目的React内部组件。特别是，React Native for Web过去常常依赖于事件系统的某些内部组件，但这种依赖关系很脆弱且经常被破坏。")]),t._v(" "),e("p",[t._v("在React 17中，这些私有导出已被移除。据我们所知，React Native for Web是唯一使用它们的项目，它们已经完成了向不依赖那些私有导出函数的其他方法迁移。")]),t._v(" "),e("p",[t._v("这意味着旧版本的React Native for Web不会与React 17兼容，但是新版本可以使用它。实际上，并没有太大的变化，因为React Native for Web必须发布新版本以适应其内部React的变化。")]),t._v(" "),e("p",[t._v("另外，我们删除了ReactTestUtils.SimulateNative的helper方法。他们从未被记录，没有按照他们名字所暗示的那样去做，也没有处理我们对事件系统所做的更改。如果你想要一种简便的方式来触发测试中原生浏览器的事件，请改用 React Testing Library。")]),t._v(" "),e("h2",{attrs:{id:"对标浏览器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对标浏览器"}},[t._v("#")]),t._v(" 对标浏览器")]),t._v(" "),e("ul",[e("li",[t._v("onScroll事件不再冒泡，以防止出现一些混淆。")]),t._v(" "),e("li",[t._v("React的onFocus和onBlur事件已在底层切换为原生的focusin和focusout事件。它们更接近React现有行为，有时还会提供额外的信息。")]),t._v(" "),e("li",[t._v("捕获事件(例如，onClickCapture)现在使用的是实际浏览器中的捕获监听器。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);