<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>promise介绍 | szx的前端博客</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="专注前端">
    
    <link rel="preload" href="/szxblog-demo/assets/css/0.styles.bb1aa129.css" as="style"><link rel="preload" href="/szxblog-demo/assets/js/app.e2c00437.js" as="script"><link rel="preload" href="/szxblog-demo/assets/js/2.8f1423a4.js" as="script"><link rel="preload" href="/szxblog-demo/assets/js/112.0ac71cc1.js" as="script"><link rel="prefetch" href="/szxblog-demo/assets/js/10.f16ead29.js"><link rel="prefetch" href="/szxblog-demo/assets/js/100.8cadd01d.js"><link rel="prefetch" href="/szxblog-demo/assets/js/101.a4878c9d.js"><link rel="prefetch" href="/szxblog-demo/assets/js/102.991e43a1.js"><link rel="prefetch" href="/szxblog-demo/assets/js/103.7d14ce32.js"><link rel="prefetch" href="/szxblog-demo/assets/js/104.d890ed53.js"><link rel="prefetch" href="/szxblog-demo/assets/js/105.bcd4ee5b.js"><link rel="prefetch" href="/szxblog-demo/assets/js/106.4518dab2.js"><link rel="prefetch" href="/szxblog-demo/assets/js/107.db11e77b.js"><link rel="prefetch" href="/szxblog-demo/assets/js/108.cc1b835b.js"><link rel="prefetch" href="/szxblog-demo/assets/js/109.79708b6d.js"><link rel="prefetch" href="/szxblog-demo/assets/js/11.b2e33f60.js"><link rel="prefetch" href="/szxblog-demo/assets/js/110.fe6a2f06.js"><link rel="prefetch" href="/szxblog-demo/assets/js/111.d68806ae.js"><link rel="prefetch" href="/szxblog-demo/assets/js/113.4a09aadd.js"><link rel="prefetch" href="/szxblog-demo/assets/js/114.963a5822.js"><link rel="prefetch" href="/szxblog-demo/assets/js/115.1aad30ca.js"><link rel="prefetch" href="/szxblog-demo/assets/js/116.12dfadff.js"><link rel="prefetch" href="/szxblog-demo/assets/js/117.dd997115.js"><link rel="prefetch" href="/szxblog-demo/assets/js/118.4f5c2734.js"><link rel="prefetch" href="/szxblog-demo/assets/js/119.5e4017d2.js"><link rel="prefetch" href="/szxblog-demo/assets/js/12.39e4e465.js"><link rel="prefetch" href="/szxblog-demo/assets/js/120.1d59b549.js"><link rel="prefetch" href="/szxblog-demo/assets/js/121.46cb657a.js"><link rel="prefetch" href="/szxblog-demo/assets/js/122.ebd8bc25.js"><link rel="prefetch" href="/szxblog-demo/assets/js/123.e3995884.js"><link rel="prefetch" href="/szxblog-demo/assets/js/124.843940bf.js"><link rel="prefetch" href="/szxblog-demo/assets/js/125.e05870f4.js"><link rel="prefetch" href="/szxblog-demo/assets/js/126.d37e314f.js"><link rel="prefetch" href="/szxblog-demo/assets/js/127.144f4e65.js"><link rel="prefetch" href="/szxblog-demo/assets/js/128.317156a7.js"><link rel="prefetch" href="/szxblog-demo/assets/js/129.e6323ab6.js"><link rel="prefetch" href="/szxblog-demo/assets/js/13.4a7ec971.js"><link rel="prefetch" href="/szxblog-demo/assets/js/130.9fad7606.js"><link rel="prefetch" href="/szxblog-demo/assets/js/131.b0cb52b7.js"><link rel="prefetch" href="/szxblog-demo/assets/js/132.5f4869e4.js"><link rel="prefetch" href="/szxblog-demo/assets/js/133.f759d537.js"><link rel="prefetch" href="/szxblog-demo/assets/js/134.f81e482f.js"><link rel="prefetch" href="/szxblog-demo/assets/js/135.8b76bf3a.js"><link rel="prefetch" href="/szxblog-demo/assets/js/136.ec7497a6.js"><link rel="prefetch" href="/szxblog-demo/assets/js/137.1c138540.js"><link rel="prefetch" href="/szxblog-demo/assets/js/138.757a6d32.js"><link rel="prefetch" href="/szxblog-demo/assets/js/139.b64fe6dd.js"><link rel="prefetch" href="/szxblog-demo/assets/js/14.9bc2db88.js"><link rel="prefetch" href="/szxblog-demo/assets/js/140.8e37e5b2.js"><link rel="prefetch" href="/szxblog-demo/assets/js/141.b5039787.js"><link rel="prefetch" href="/szxblog-demo/assets/js/142.77101e82.js"><link rel="prefetch" href="/szxblog-demo/assets/js/143.ff805ccd.js"><link rel="prefetch" href="/szxblog-demo/assets/js/144.4ad37531.js"><link rel="prefetch" href="/szxblog-demo/assets/js/145.304b1b9e.js"><link rel="prefetch" href="/szxblog-demo/assets/js/146.4600c2a5.js"><link rel="prefetch" href="/szxblog-demo/assets/js/147.a36d58c2.js"><link rel="prefetch" href="/szxblog-demo/assets/js/148.6889700a.js"><link rel="prefetch" href="/szxblog-demo/assets/js/149.105878b7.js"><link rel="prefetch" href="/szxblog-demo/assets/js/15.4d9798a0.js"><link rel="prefetch" href="/szxblog-demo/assets/js/150.cf5bfd3f.js"><link rel="prefetch" href="/szxblog-demo/assets/js/151.86e5595c.js"><link rel="prefetch" href="/szxblog-demo/assets/js/152.3c259509.js"><link rel="prefetch" href="/szxblog-demo/assets/js/153.499607de.js"><link rel="prefetch" href="/szxblog-demo/assets/js/154.90874a75.js"><link rel="prefetch" href="/szxblog-demo/assets/js/155.4cd7b50f.js"><link rel="prefetch" href="/szxblog-demo/assets/js/156.6acd428c.js"><link rel="prefetch" href="/szxblog-demo/assets/js/16.def8c8a5.js"><link rel="prefetch" href="/szxblog-demo/assets/js/17.14956b0e.js"><link rel="prefetch" href="/szxblog-demo/assets/js/18.b6609ccd.js"><link rel="prefetch" href="/szxblog-demo/assets/js/19.3f2404b2.js"><link rel="prefetch" href="/szxblog-demo/assets/js/20.904beb92.js"><link rel="prefetch" href="/szxblog-demo/assets/js/21.aeee3703.js"><link rel="prefetch" href="/szxblog-demo/assets/js/22.fe438878.js"><link rel="prefetch" href="/szxblog-demo/assets/js/23.d8da336b.js"><link rel="prefetch" href="/szxblog-demo/assets/js/24.250498f2.js"><link rel="prefetch" href="/szxblog-demo/assets/js/25.22a76a93.js"><link rel="prefetch" href="/szxblog-demo/assets/js/26.d08fabd4.js"><link rel="prefetch" href="/szxblog-demo/assets/js/27.a5b15e7c.js"><link rel="prefetch" href="/szxblog-demo/assets/js/28.d047c227.js"><link rel="prefetch" href="/szxblog-demo/assets/js/29.e067aba3.js"><link rel="prefetch" href="/szxblog-demo/assets/js/3.4a4dea6a.js"><link rel="prefetch" href="/szxblog-demo/assets/js/30.a4cb4a9a.js"><link rel="prefetch" href="/szxblog-demo/assets/js/31.9cc73361.js"><link rel="prefetch" href="/szxblog-demo/assets/js/32.1551ca83.js"><link rel="prefetch" href="/szxblog-demo/assets/js/33.2f9aa824.js"><link rel="prefetch" href="/szxblog-demo/assets/js/34.62952cfb.js"><link rel="prefetch" href="/szxblog-demo/assets/js/35.dad7516d.js"><link rel="prefetch" href="/szxblog-demo/assets/js/36.bf7157c4.js"><link rel="prefetch" href="/szxblog-demo/assets/js/37.304a1cd2.js"><link rel="prefetch" href="/szxblog-demo/assets/js/38.6490f3d9.js"><link rel="prefetch" href="/szxblog-demo/assets/js/39.08e18c05.js"><link rel="prefetch" href="/szxblog-demo/assets/js/4.0b45e3e3.js"><link rel="prefetch" href="/szxblog-demo/assets/js/40.091f41cc.js"><link rel="prefetch" href="/szxblog-demo/assets/js/41.553cae9a.js"><link rel="prefetch" href="/szxblog-demo/assets/js/42.e5a8f335.js"><link rel="prefetch" href="/szxblog-demo/assets/js/43.8a1233c4.js"><link rel="prefetch" href="/szxblog-demo/assets/js/44.d66aa0af.js"><link rel="prefetch" href="/szxblog-demo/assets/js/45.4ec2ac39.js"><link rel="prefetch" href="/szxblog-demo/assets/js/46.6de0879e.js"><link rel="prefetch" href="/szxblog-demo/assets/js/47.192a18b2.js"><link rel="prefetch" href="/szxblog-demo/assets/js/48.6ab2ae0b.js"><link rel="prefetch" href="/szxblog-demo/assets/js/49.3e7963e6.js"><link rel="prefetch" href="/szxblog-demo/assets/js/5.033e198f.js"><link rel="prefetch" href="/szxblog-demo/assets/js/50.a0a03c35.js"><link rel="prefetch" href="/szxblog-demo/assets/js/51.0d2cbfe9.js"><link rel="prefetch" href="/szxblog-demo/assets/js/52.15164a8d.js"><link rel="prefetch" href="/szxblog-demo/assets/js/53.34bd92b6.js"><link rel="prefetch" href="/szxblog-demo/assets/js/54.aab05585.js"><link rel="prefetch" href="/szxblog-demo/assets/js/55.ecba2087.js"><link rel="prefetch" href="/szxblog-demo/assets/js/56.3c2504c8.js"><link rel="prefetch" href="/szxblog-demo/assets/js/57.802af9b6.js"><link rel="prefetch" href="/szxblog-demo/assets/js/58.c475375a.js"><link rel="prefetch" href="/szxblog-demo/assets/js/59.31a836d2.js"><link rel="prefetch" href="/szxblog-demo/assets/js/6.243d2d74.js"><link rel="prefetch" href="/szxblog-demo/assets/js/60.8a892df5.js"><link rel="prefetch" href="/szxblog-demo/assets/js/61.c2bde899.js"><link rel="prefetch" href="/szxblog-demo/assets/js/62.687e89b4.js"><link rel="prefetch" href="/szxblog-demo/assets/js/63.526d56d4.js"><link rel="prefetch" href="/szxblog-demo/assets/js/64.90076339.js"><link rel="prefetch" href="/szxblog-demo/assets/js/65.48a56802.js"><link rel="prefetch" href="/szxblog-demo/assets/js/66.f5339f49.js"><link rel="prefetch" href="/szxblog-demo/assets/js/67.63db5c44.js"><link rel="prefetch" href="/szxblog-demo/assets/js/68.436134dd.js"><link rel="prefetch" href="/szxblog-demo/assets/js/69.7c87a09b.js"><link rel="prefetch" href="/szxblog-demo/assets/js/7.c1c64325.js"><link rel="prefetch" href="/szxblog-demo/assets/js/70.f77a5e7f.js"><link rel="prefetch" href="/szxblog-demo/assets/js/71.21dc29e2.js"><link rel="prefetch" href="/szxblog-demo/assets/js/72.87cf2239.js"><link rel="prefetch" href="/szxblog-demo/assets/js/73.4cea3242.js"><link rel="prefetch" href="/szxblog-demo/assets/js/74.32b5d7d2.js"><link rel="prefetch" href="/szxblog-demo/assets/js/75.b1ed8ded.js"><link rel="prefetch" href="/szxblog-demo/assets/js/76.81b226bc.js"><link rel="prefetch" href="/szxblog-demo/assets/js/77.ed4d0c4e.js"><link rel="prefetch" href="/szxblog-demo/assets/js/78.90521550.js"><link rel="prefetch" href="/szxblog-demo/assets/js/79.1664cd3f.js"><link rel="prefetch" href="/szxblog-demo/assets/js/8.f59080dd.js"><link rel="prefetch" href="/szxblog-demo/assets/js/80.4792b8a8.js"><link rel="prefetch" href="/szxblog-demo/assets/js/81.96f7a53e.js"><link rel="prefetch" href="/szxblog-demo/assets/js/82.763974fd.js"><link rel="prefetch" href="/szxblog-demo/assets/js/83.48bb4590.js"><link rel="prefetch" href="/szxblog-demo/assets/js/84.3b365bc6.js"><link rel="prefetch" href="/szxblog-demo/assets/js/85.705ddf29.js"><link rel="prefetch" href="/szxblog-demo/assets/js/86.7d8aeacf.js"><link rel="prefetch" href="/szxblog-demo/assets/js/87.4086e29b.js"><link rel="prefetch" href="/szxblog-demo/assets/js/88.8a8c76de.js"><link rel="prefetch" href="/szxblog-demo/assets/js/89.f9dc7fd3.js"><link rel="prefetch" href="/szxblog-demo/assets/js/9.d75d0d70.js"><link rel="prefetch" href="/szxblog-demo/assets/js/90.b4a00719.js"><link rel="prefetch" href="/szxblog-demo/assets/js/91.852f9720.js"><link rel="prefetch" href="/szxblog-demo/assets/js/92.83f5a96e.js"><link rel="prefetch" href="/szxblog-demo/assets/js/93.c6bfc105.js"><link rel="prefetch" href="/szxblog-demo/assets/js/94.581e0e89.js"><link rel="prefetch" href="/szxblog-demo/assets/js/95.9fb6788d.js"><link rel="prefetch" href="/szxblog-demo/assets/js/96.e78a3c64.js"><link rel="prefetch" href="/szxblog-demo/assets/js/97.9a67fc48.js"><link rel="prefetch" href="/szxblog-demo/assets/js/98.46f07266.js"><link rel="prefetch" href="/szxblog-demo/assets/js/99.87034f0f.js">
    <link rel="stylesheet" href="/szxblog-demo/assets/css/0.styles.bb1aa129.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/szxblog-demo/" class="home-link router-link-active"><!----> <span class="site-name">szx的前端博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端日报" class="dropdown-title"><span class="title">前端日报</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端日报" class="mobile-dropdown-title"><span class="title">前端日报</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/szxblog-demo/dailyFrontReport/2020/06/" class="nav-link">
  202006
</a></li><li class="dropdown-item"><!----> <a href="/szxblog-demo/dailyFrontReport/2020/07/" class="nav-link">
  202007
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术分类" class="dropdown-title"><span class="title">技术分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术分类" class="mobile-dropdown-title"><span class="title">技术分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/szxblog-demo/tech/js/" class="nav-link router-link-active">
  js
</a></li><li class="dropdown-item"><!----> <a href="/szxblog-demo/tech/css/" class="nav-link">
  css
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="常用站点" class="dropdown-title"><span class="title">常用站点</span> <span class="arrow down"></span></button> <button type="button" aria-label="常用站点" class="mobile-dropdown-title"><span class="title">常用站点</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://www.jianshu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.im/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://wubaiqing.github.io/zaobao/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  每日时报
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/trending" target="_blank" rel="noopener noreferrer" class="nav-link external">
  技术趋势
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端日报" class="dropdown-title"><span class="title">前端日报</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端日报" class="mobile-dropdown-title"><span class="title">前端日报</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/szxblog-demo/dailyFrontReport/2020/06/" class="nav-link">
  202006
</a></li><li class="dropdown-item"><!----> <a href="/szxblog-demo/dailyFrontReport/2020/07/" class="nav-link">
  202007
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术分类" class="dropdown-title"><span class="title">技术分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术分类" class="mobile-dropdown-title"><span class="title">技术分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/szxblog-demo/tech/js/" class="nav-link router-link-active">
  js
</a></li><li class="dropdown-item"><!----> <a href="/szxblog-demo/tech/css/" class="nav-link">
  css
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="常用站点" class="dropdown-title"><span class="title">常用站点</span> <span class="arrow down"></span></button> <button type="button" aria-label="常用站点" class="mobile-dropdown-title"><span class="title">常用站点</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://www.jianshu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  简书
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.im/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://wubaiqing.github.io/zaobao/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  每日时报
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/trending" target="_blank" rel="noopener noreferrer" class="nav-link external">
  技术趋势
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>promise介绍</span> <!----></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="promise介绍"><a href="#promise介绍" class="header-anchor">#</a> promise介绍</h1> <ul><li>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</li></ul> <p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p> <p>Promise对象有以下两个特点。</p> <p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p> <p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p> <p>注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。</p> <p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p> <p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p> <p>如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。</p> <p>基本用法
ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p> <p>下面代码创造了一个Promise实例。</p> <p>const promise = new Promise(function(resolve, reject) {
// ... some code</p> <p>if (/* 异步操作成功 */){
resolve(value);
} else {
reject(error);
}
});
Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p> <p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p> <p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p> <p>promise.then(function(value) {
// success
}, function(error) {
// failure
});
then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p> <p>下面是一个Promise对象的简单例子。</p> <p>function timeout(ms) {
return new Promise((resolve, reject) =&gt; {
setTimeout(resolve, ms, 'done');
});
}</p> <p>timeout(100).then((value) =&gt; {
console.log(value);
});
上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。</p> <p>Promise 新建后就会立即执行。</p> <p>let promise = new Promise(function(resolve, reject) {
console.log('Promise');
resolve();
});</p> <p>promise.then(function() {
console.log('resolved.');
});</p> <p>console.log('Hi!');</p> <p>// Promise
// Hi!
// resolved
上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</p> <p>下面是异步加载图片的例子。</p> <p>function loadImageAsync(url) {
return new Promise(function(resolve, reject) {
const image = new Image();</p> <div class="language- extra-class"><pre><code>image.onload = function() {
  resolve(image);
};

image.onerror = function() {
  reject(new Error('Could not load image at ' + url));
};

image.src = url;
</code></pre></div><p>});
}
上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。</p> <p>下面是一个用Promise对象实现的 Ajax 操作的例子。</p> <p>const getJSON = function(url) {
const promise = new Promise(function(resolve, reject){
const handler = function() {
if (this.readyState !== 4) {
return;
}
if (this.status === 200) {
resolve(this.response);
} else {
reject(new Error(this.statusText));
}
};
const client = new XMLHttpRequest();
client.open(&quot;GET&quot;, url);
client.onreadystatechange = handler;
client.responseType = &quot;json&quot;;
client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
client.send();</p> <p>});</p> <p>return promise;
};</p> <p>getJSON(&quot;/posts.json&quot;).then(function(json) {
console.log('Contents: ' + json);
}, function(error) {
console.error('出错了', error);
});
上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p> <p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p> <p>const p1 = new Promise(function (resolve, reject) {
// ...
});</p> <p>const p2 = new Promise(function (resolve, reject) {
// ...
resolve(p1);
})
上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p> <p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</p> <p>const p1 = new Promise(function (resolve, reject) {
setTimeout(() =&gt; reject(new Error('fail')), 3000)
})</p> <p>const p2 = new Promise(function (resolve, reject) {
setTimeout(() =&gt; resolve(p1), 1000)
})</p> <p>p2
.then(result =&gt; console.log(result))
.catch(error =&gt; console.log(error))
// Error: fail
上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p> <p>注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。</p> <p>new Promise((resolve, reject) =&gt; {
resolve(1);
console.log(2);
}).then(r =&gt; {
console.log(r);
});
// 2
// 1
上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p> <p>一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。</p> <p>new Promise((resolve, reject) =&gt; {
return resolve(1);
// 后面的语句不会执行
console.log(2);
})
Promise.prototype.then()
Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p> <p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p> <p>getJSON(&quot;/posts.json&quot;).then(function(json) {
return json.post;
}).then(function(post) {
// ...
});
上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p> <p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p> <p>getJSON(&quot;/post/1.json&quot;).then(function(post) {
return getJSON(post.commentURL);
}).then(function (comments) {
console.log(&quot;resolved: &quot;, comments);
}, function (err){
console.log(&quot;rejected: &quot;, err);
});
上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。</p> <p>如果采用箭头函数，上面的代码可以写得更简洁。</p> <p>getJSON(&quot;/post/1.json&quot;).then(
post =&gt; getJSON(post.commentURL)
).then(
comments =&gt; console.log(&quot;resolved: &quot;, comments),
err =&gt; console.log(&quot;rejected: &quot;, err)
);
Promise.prototype.catch()
Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p> <p>getJSON('/posts.json').then(function(posts) {
// ...
}).catch(function(error) {
// 处理 getJSON 和 前一个回调函数运行时发生的错误
console.log('发生错误！', error);
});
上面代码中，getJSON()方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then()方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误。另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。</p> <p>p.then((val) =&gt; console.log('fulfilled:', val))
.catch((err) =&gt; console.log('rejected', err));</p> <p>// 等同于
p.then((val) =&gt; console.log('fulfilled:', val))
.then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
下面是一个例子。</p> <p>const promise = new Promise(function(resolve, reject) {
throw new Error('test');
});
promise.catch(function(error) {
console.log(error);
});
// Error: test
上面代码中，promise抛出一个错误，就被catch()方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p> <p>// 写法一
const promise = new Promise(function(resolve, reject) {
try {
throw new Error('test');
} catch(e) {
reject(e);
}
});
promise.catch(function(error) {
console.log(error);
});</p> <p>// 写法二
const promise = new Promise(function(resolve, reject) {
reject(new Error('test'));
});
promise.catch(function(error) {
console.log(error);
});
比较上面两种写法，可以发现reject()方法的作用，等同于抛出错误。</p> <p>如果 Promise 状态已经变成resolved，再抛出错误是无效的。</p> <p>const promise = new Promise(function(resolve, reject) {
resolve('ok');
throw new Error('test');
});
promise
.then(function(value) { console.log(value) })
.catch(function(error) { console.log(error) });
// ok
上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p> <p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p> <p>getJSON('/post/1.json').then(function(post) {
return getJSON(post.commentURL);
}).then(function(comments) {
// some code
}).catch(function(error) {
// 处理前面三个Promise产生的错误
});
上面代码中，一共有三个 Promise 对象：一个由getJSON()产生，两个由then()产生。它们之中任何一个抛出的错误，都会被最后一个catch()捕获。</p> <p>一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</p> <p>// bad
promise
.then(function(data) {
// success
}, function(err) {
// error
});</p> <p>// good
promise
.then(function(data) { //cb
// success
})
.catch(function(err) {
// error
});
上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch()方法，而不使用then()方法的第二个参数。</p> <p>跟传统的try/catch代码块不同的是，如果没有使用catch()方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p> <p>const someAsyncThing = function() {
return new Promise(function(resolve, reject) {
// 下面一行会报错，因为x没有声明
resolve(x + 2);
});
};</p> <p>someAsyncThing().then(function() {
console.log('everything is great');
});</p> <p>setTimeout(() =&gt; { console.log(123) }, 2000);
// Uncaught (in promise) ReferenceError: x is not defined
// 123
上面代码中，someAsyncThing()函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p> <p>这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，Node.js 有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p> <p>process.on('unhandledRejection', function (err, p) {
throw err;
});
上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p> <p>注意，Node 有计划在未来废除unhandledRejection事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p> <p>再看下面的例子。</p> <p>const promise = new Promise(function (resolve, reject) {
resolve('ok');
setTimeout(function () { throw new Error('test') }, 0)
});
promise.then(function (value) { console.log(value) });
// ok
// Uncaught Error: test
上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p> <p>一般总是建议，Promise 对象后面要跟catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。</p> <p>const someAsyncThing = function() {
return new Promise(function(resolve, reject) {
// 下面一行会报错，因为x没有声明
resolve(x + 2);
});
};</p> <p>someAsyncThing()
.catch(function(error) {
console.log('oh no', error);
})
.then(function() {
console.log('carry on');
});
// oh no [ReferenceError: x is not defined]
// carry on
上面代码运行完catch()方法指定的回调函数，会接着运行后面那个then()方法指定的回调函数。如果没有报错，则会跳过catch()方法。</p> <p>Promise.resolve()
.catch(function(error) {
console.log('oh no', error);
})
.then(function() {
console.log('carry on');
});
// carry on
上面的代码因为没有报错，跳过了catch()方法，直接执行后面的then()方法。此时，要是then()方法里面报错，就与前面的catch()无关了。</p> <p>catch()方法之中，还能再抛出错误。</p> <p>const someAsyncThing = function() {
return new Promise(function(resolve, reject) {
// 下面一行会报错，因为x没有声明
resolve(x + 2);
});
};</p> <p>someAsyncThing().then(function() {
return someOtherAsyncThing();
}).catch(function(error) {
console.log('oh no', error);
// 下面一行会报错，因为 y 没有声明
y + 2;
}).then(function() {
console.log('carry on');
});
// oh no [ReferenceError: x is not defined]
上面代码中，catch()方法抛出一个错误，因为后面没有别的catch()方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p> <p>someAsyncThing().then(function() {
return someOtherAsyncThing();
}).catch(function(error) {
console.log('oh no', error);
// 下面一行会报错，因为y没有声明
y + 2;
}).catch(function(error) {
console.log('carry on', error);
});
// oh no [ReferenceError: x is not defined]
// carry on [ReferenceError: y is not defined]
上面代码中，第二个catch()方法用来捕获前一个catch()方法抛出的错误。</p> <p>Promise.prototype.finally()
finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p> <p>promise
.then(result =&gt; {···})
.catch(error =&gt; {···})
.finally(() =&gt; {···});
上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p> <p>下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。</p> <p>server.listen(port)
.then(function () {
// ...
})
.finally(server.stop);
finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p> <p>finally本质上是then方法的特例。</p> <p>promise
.finally(() =&gt; {
// 语句
});</p> <p>// 等同于
promise
.then(
result =&gt; {
// 语句
return result;
},
error =&gt; {
// 语句
throw error;
}
);
上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。</p> <p>它的实现也很简单。</p> <p>Promise.prototype.finally = function (callback) {
let P = this.constructor;
return this.then(
value  =&gt; P.resolve(callback()).then(() =&gt; value),
reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })
);
};
上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。</p> <p>从上面的实现还可以看到，finally方法总是会返回原来的值。</p> <p>// resolve 的值是 undefined
Promise.resolve(2).then(() =&gt; {}, () =&gt; {})</p> <p>// resolve 的值是 2
Promise.resolve(2).finally(() =&gt; {})</p> <p>// reject 的值是 undefined
Promise.reject(3).then(() =&gt; {}, () =&gt; {})</p> <p>// reject 的值是 3
Promise.reject(3).finally(() =&gt; {})
Promise.all()
Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p> <p>const p = Promise.all([p1, p2, p3]);
上面代码中，Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p> <p>p的状态由p1、p2、p3决定，分成两种情况。</p> <p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p> <p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p> <p>下面是一个具体的例子。</p> <p>// 生成一个Promise对象的数组
const promises = [2, 3, 5, 7, 11, 13].map(function (id) {
return getJSON('/post/' + id + &quot;.json&quot;);
});</p> <p>Promise.all(promises).then(function (posts) {
// ...
}).catch(function(reason){
// ...
});
上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。</p> <p>下面是另一个例子。</p> <p>const databasePromise = connectDatabase();</p> <p>const booksPromise = databasePromise
.then(findAllBooks);</p> <p>const userPromise = databasePromise
.then(getCurrentUser);</p> <p>Promise.all([
booksPromise,
userPromise
])
.then(([books, user]) =&gt; pickTopRecommendations(books, user));
上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。</p> <p>注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</p> <p>const p1 = new Promise((resolve, reject) =&gt; {
resolve('hello');
})
.then(result =&gt; result)
.catch(e =&gt; e);</p> <p>const p2 = new Promise((resolve, reject) =&gt; {
throw new Error('报错了');
})
.then(result =&gt; result)
.catch(e =&gt; e);</p> <p>Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。</p> <p>如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。</p> <p>const p1 = new Promise((resolve, reject) =&gt; {
resolve('hello');
})
.then(result =&gt; result);</p> <p>const p2 = new Promise((resolve, reject) =&gt; {
throw new Error('报错了');
})
.then(result =&gt; result);</p> <p>Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// Error: 报错了
Promise.race()
Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p> <p>const p = Promise.race([p1, p2, p3]);
上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p> <p>Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。</p> <p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。</p> <p>const p = Promise.race([
fetch('/resource-that-may-take-a-while'),
new Promise(function (resolve, reject) {
setTimeout(() =&gt; reject(new Error('request timeout')), 5000)
})
]);</p> <p>p
.then(console.log)
.catch(console.error);
上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</p> <p>Promise.allSettled()
Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。</p> <p>const promises = [
fetch('/api-1'),
fetch('/api-2'),
fetch('/api-3'),
];</p> <p>await Promise.allSettled(promises);
removeLoadingIndicator();
上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p> <p>该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。</p> <p>const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);</p> <p>const allSettledPromise = Promise.allSettled([resolved, rejected]);</p> <p>allSettledPromise.then(function (results) {
console.log(results);
});
// [
//    { status: 'fulfilled', value: 42 },
//    { status: 'rejected', reason: -1 }
// ]
上面代码中，Promise.allSettled()的返回值allSettledPromise，状态只可能变成fulfilled。它的监听函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应传入Promise.allSettled()的两个 Promise 实例。每个对象都有status属性，该属性的值只可能是字符串fulfilled或字符串rejected。fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。</p> <p>下面是返回值用法的例子。</p> <p>const promises = [ fetch('index.html'), fetch('https://does-not-exist/') ];
const results = await Promise.allSettled(promises);</p> <p>// 过滤出成功的请求
const successfulPromises = results.filter(p =&gt; p.status === 'fulfilled');</p> <p>// 过滤出失败的请求，并输出原因
const errors = results
.filter(p =&gt; p.status === 'rejected')
.map(p =&gt; p.reason);
有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all()方法无法做到这一点。</p> <p>const urls = [ /* ... */ ];
const requests = urls.map(x =&gt; fetch(x));</p> <p>try {
await Promise.all(requests);
console.log('所有请求都成功。');
} catch {
console.log('至少一个请求失败，其他请求可能还没结束。');
}
上面代码中，Promise.all()无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了Promise.allSettled()，这就很容易了。</p> <p>Promise.any()
Promise.any()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。该方法目前是一个第三阶段的提案 。</p> <p>Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。</p> <p>const promises = [
fetch('/endpoint-a').then(() =&gt; 'a'),
fetch('/endpoint-b').then(() =&gt; 'b'),
fetch('/endpoint-c').then(() =&gt; 'c'),
];
try {
const first = await Promise.any(promises);
console.log(first);
} catch (error) {
console.log(error);
}
上面代码中，Promise.any()方法的参数数组包含三个 Promise 操作。其中只要有一个变成fulfilled，Promise.any()返回的 Promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么await命令就会抛出错误。</p> <p>Promise.any()抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。下面是 AggregateError 的实现示例。</p> <p>new AggregateError() extends Array -&gt; AggregateError</p> <p>const err = new AggregateError();
err.push(new Error(&quot;first error&quot;));
err.push(new Error(&quot;second error&quot;));
throw err;
捕捉错误时，如果不用try...catch结构和 await 命令，可以像下面这样写。</p> <p>Promise.any(promises).then(
(first) =&gt; {
// Any of the promises was fulfilled.
},
(error) =&gt; {
// All of the promises were rejected.
}
);
下面是一个例子。</p> <p>var resolved = Promise.resolve(42);
var rejected = Promise.reject(-1);
var alsoRejected = Promise.reject(Infinity);</p> <p>Promise.any([resolved, rejected, alsoRejected]).then(function (result) {
console.log(result); // 42
});</p> <p>Promise.any([rejected, alsoRejected]).catch(function (results) {
console.log(results); // [-1, Infinity]
});
Promise.resolve()
有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。</p> <p>const jsPromise = Promise.resolve($.ajax('/whatever.json'));
上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。</p> <p>Promise.resolve()等价于下面的写法。</p> <p>Promise.resolve('foo')
// 等价于
new Promise(resolve =&gt; resolve('foo'))
Promise.resolve方法的参数分成四种情况。</p> <p>（1）参数是一个 Promise 实例</p> <p>如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p> <p>（2）参数是一个thenable对象</p> <p>thenable对象指的是具有then方法的对象，比如下面这个对象。</p> <p>let thenable = {
then: function(resolve, reject) {
resolve(42);
}
};
Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</p> <p>let thenable = {
then: function(resolve, reject) {
resolve(42);
}
};</p> <p>let p1 = Promise.resolve(thenable);
p1.then(function(value) {
console.log(value);  // 42
});
上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。</p> <p>（3）参数不是具有then方法的对象，或根本就不是对象</p> <p>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。</p> <p>const p = Promise.resolve('Hello');</p> <p>p.then(function (s){
console.log(s)
});
// Hello
上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。</p> <p>（4）不带有任何参数</p> <p>Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。</p> <p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。</p> <p>const p = Promise.resolve();</p> <p>p.then(function () {
// ...
});
上面代码的变量p就是一个 Promise 对象。</p> <p>需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p> <p>setTimeout(function () {
console.log('three');
}, 0);</p> <p>Promise.resolve().then(function () {
console.log('two');
});</p> <p>console.log('one');</p> <p>// one
// two
// three
上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。</p> <p>Promise.reject()
Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。</p> <p>const p = Promise.reject('出错了');
// 等同于
const p = new Promise((resolve, reject) =&gt; reject('出错了'))</p> <p>p.then(null, function (s) {
console.log(s)
});
// 出错了
上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。</p> <p>注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。</p> <p>const thenable = {
then(resolve, reject) {
reject('出错了');
}
};</p> <p>Promise.reject(thenable)
.catch(e =&gt; {
console.log(e === thenable)
})
// true
上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</p> <p>应用
加载图片
我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。</p> <p>const preloadImage = function (path) {
return new Promise(function (resolve, reject) {
const image = new Image();
image.onload  = resolve;
image.onerror = reject;
image.src = path;
});
};
Generator 函数与 Promise 的结合
使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。</p> <p>function getFoo () {
return new Promise(function (resolve, reject){
resolve('foo');
});
}</p> <p>const g = function* () {
try {
const foo = yield getFoo();
console.log(foo);
} catch (e) {
console.log(e);
}
};</p> <p>function run (generator) {
const it = generator();</p> <p>function go(result) {
if (result.done) return result.value;</p> <div class="language- extra-class"><pre><code>return result.value.then(function (value) {
  return go(it.next(value));
}, function (error) {
  return go(it.throw(error));
});
</code></pre></div><p>}</p> <p>go(it.next());
}</p> <p>run(g);
上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。</p> <p>Promise.try()
实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。</p> <p>Promise.resolve().then(f)
上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。</p> <p>const f = () =&gt; console.log('now');
Promise.resolve().then(f);
console.log('next');
// next
// now
上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p> <p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。</p> <p>const f = () =&gt; console.log('now');
(async () =&gt; f())();
console.log('next');
// now
// next
上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。</p> <p>(async () =&gt; f())()
.then(...)
需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。</p> <p>(async () =&gt; f())()
.then(...)
.catch(...)
第二种写法是使用new Promise()。</p> <p>const f = () =&gt; console.log('now');
(
() =&gt; new Promise(
resolve =&gt; resolve(f())
)
)();
console.log('next');
// now
// next
上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。</p> <p>鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。</p> <p>const f = () =&gt; console.log('now');
Promise.try(f);
console.log('next');
// now
// next
事实上，Promise.try存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。</p> <p>由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。</p> <p>function getUsername(userId) {
return database.users.get({id: userId})
.then(function(user) {
return user.name;
});
}
上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。</p> <p>database.users.get({id: userId})
.then(...)
.catch(...)
但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。</p> <p>try {
database.users.get({id: userId})
.then(...)
.catch(...)
} catch (e) {
// ...
}
上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。</p> <p>Promise.try(() =&gt; database.users.get({id: userId}))
.then(...)
.catch(...)
事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">11/17/2020, 9:33:55 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/szxblog-demo/assets/js/app.e2c00437.js" defer></script><script src="/szxblog-demo/assets/js/2.8f1423a4.js" defer></script><script src="/szxblog-demo/assets/js/112.0ac71cc1.js" defer></script>
  </body>
</html>
